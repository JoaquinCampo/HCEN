@startuml ComponentArchitecture
skinparam componentStyle rectangle
skinparam wrapWidth 200
skinparam maxMessageSize 200
skinparam packageStyle rectangle

package "Console Module" as Console {
  component "Main" as ConsoleMain
  component "ServiceLocator" as ConsoleLocator
  component "JMS Producers\n(Remote)" as ConsoleJms
}

note right of Console
  Standalone CLI packaged outside the EAR
end note

package "Web Module" as Web {
  component "REST API\n(HealthUserResource, etc.)" as RestApi
  component "SOAP Services" as SoapServices
  component "JSF UI Beans" as JsfBeans
}

package "EJB Module" as Ejb {
  component "Stateless Services\n(HealthUserServiceBean, ClinicServiceBean, ...)" as EjbServices
  component "Repositories\n(JPA access)" as EjbRepositories
  component "Messaging Producers" as EjbProducers
  component "Message-Driven Beans" as EjbMdbs
  component "JPA Entities\n(User, Clinic, ClinicalDocument, ...)" as EjbEntities
}

database "PostgreSQL DB" as Database
queue "JMS Queue\n(queue_alta_health_user, queue_alta_health_worker)" as Queue
component "EAR Packaging\n(practico-ear)" as Ear

ConsoleMain --> ConsoleLocator : Remote lookup (JNDI)
ConsoleLocator --> EjbServices : invoke *Remote* interfaces
ConsoleMain --> ConsoleJms : enqueue DTOs
ConsoleJms --> Queue : send JMS messages

RestApi --> EjbServices : invoke *Local* interfaces
SoapServices --> EjbServices
JsfBeans --> EjbServices
RestApi --> EjbProducers : enqueue
SoapServices --> EjbProducers

EjbServices --> EjbRepositories : CRUD via JPA
EjbRepositories --> EjbEntities
EjbServices --> Database

EjbProducers --> Queue
Queue --> EjbMdbs : asynchronous delivery
EjbMdbs --> EjbServices : delegate business logic

Ear .down.> Web
Ear .down.> Ejb

@enduml
